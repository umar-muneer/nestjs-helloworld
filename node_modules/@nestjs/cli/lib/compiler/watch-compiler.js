"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const errors_1 = require("../ui/errors");
const get_value_or_default_1 = require("./helpers/get-value-or-default");
const tsconfig_paths_hook_1 = require("./hooks/tsconfig-paths.hook");
class WatchCompiler {
    constructor(pluginsLoader, tsConfigProvider) {
        this.pluginsLoader = pluginsLoader;
        this.tsConfigProvider = tsConfigProvider;
    }
    run(configuration, configFilename, appName, onSuccess) {
        const configPath = ts.findConfigFile(process.cwd(), ts.sys.fileExists, configFilename);
        if (!configPath) {
            throw new Error(errors_1.CLI_ERRORS.MISSING_TYPESCRIPT(configFilename));
        }
        const { projectReferences } = this.tsConfigProvider.getByConfigFilename(configFilename);
        const createProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram;
        const origDiagnosticReporter = ts.createDiagnosticReporter(ts.sys, true);
        const origWatchStatusReporter = ts.createWatchStatusReporter(ts.sys);
        const host = ts.createWatchCompilerHost(configPath, {}, ts.sys, createProgram, this.createDiagnosticReporter(origDiagnosticReporter), this.createWatchStatusChanged(origWatchStatusReporter, onSuccess));
        const pluginsConfig = get_value_or_default_1.getValueOrDefault(configuration, 'compilerOptions.plugins', appName);
        const plugins = this.pluginsLoader.load(pluginsConfig);
        const origCreateProgram = host.createProgram;
        host.createProgram = (rootNames, options, 
        // tslint:disable-next-line:no-shadowed-variable
        host, oldProgram) => {
            const tsconfigPathsPlugin = tsconfig_paths_hook_1.tsconfigPathsBeforeHookFactory(options);
            plugins.beforeHooks.push(tsconfigPathsPlugin);
            const program = origCreateProgram(rootNames, options, host, oldProgram, undefined, projectReferences);
            const origProgramEmit = program.emit;
            program.emit = (targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers) => {
                let transforms = customTransformers;
                transforms = typeof transforms !== 'object' ? {} : transforms;
                transforms.before = plugins.beforeHooks.concat(transforms.before || []);
                transforms.after = plugins.afterHooks.concat(transforms.after || []);
                return origProgramEmit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, transforms);
            };
            return program;
        };
        ts.createWatchProgram(host);
    }
    createDiagnosticReporter(diagnosticReporter) {
        return function (diagnostic, ...args) {
            return diagnosticReporter.call(this, diagnostic, ...args);
        };
    }
    createWatchStatusChanged(watchStatusReporter, onSuccess) {
        return function (diagnostic, ...args) {
            const messageText = diagnostic && diagnostic.messageText;
            const noErrorsMessage = '0 errors';
            if (messageText &&
                messageText.includes &&
                messageText.includes(noErrorsMessage) &&
                onSuccess) {
                onSuccess();
            }
            return watchStatusReporter.call(this, diagnostic, ...args);
        };
    }
}
exports.WatchCompiler = WatchCompiler;
